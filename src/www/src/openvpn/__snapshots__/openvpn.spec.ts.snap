// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`openVpn connect() should be able to connect and emit commands 1`] = `
Object {
  "bytecount": Observable {
    "_isScalar": false,
    "operator": MapOperator {
      "project": [Function],
      "thisArg": undefined,
    },
    "source": Observable {
      "_isScalar": false,
      "operator": MapOperator {
        "project": [Function],
        "thisArg": undefined,
      },
      "source": Observable {
        "_isScalar": false,
        "operator": MapOperator {
          "project": [Function],
          "thisArg": undefined,
        },
        "source": Observable {
          "_isScalar": false,
          "operator": FilterOperator {
            "predicate": [Function],
            "thisArg": undefined,
          },
          "source": Observable {
            "_isScalar": false,
            "source": Subject {
              "_isScalar": false,
              "closed": false,
              "hasError": false,
              "isStopped": false,
              "observers": Array [],
              "thrownError": null,
            },
          },
        },
      },
    },
  },
  "bytecountRequest": [Function],
  "loadStats": Observable {
    "_isScalar": false,
    "operator": SwitchMapOperator {
      "project": [Function],
    },
    "source": Observable {
      "_isScalar": false,
      "operator": TimeoutWithOperator {
        "absoluteTimeout": false,
        "scheduler": AsyncScheduler {
          "SchedulerAction": [Function],
          "actions": Array [],
          "active": false,
          "now": [Function],
          "scheduled": undefined,
        },
        "waitFor": 1000,
        "withObservable": Observable {
          "_isScalar": false,
          "_subscribe": [Function],
        },
      },
      "source": Observable {
        "_isScalar": false,
        "operator": FilterOperator {
          "predicate": [Function],
          "thisArg": undefined,
        },
        "source": Observable {
          "_isScalar": false,
          "operator": CatchOperator {
            "caught": [Circular],
            "selector": [Function],
          },
          "source": Observable {
            "_isScalar": false,
            "operator": MapToOperator {
              "value": true,
            },
            "source": Observable {
              "_isScalar": false,
              "operator": MergeMapOperator {
                "concurrent": Infinity,
                "project": [Function],
              },
              "source": Observable {
                "_isScalar": false,
                "operator": FilterOperator {
                  "predicate": [Function],
                  "thisArg": undefined,
                },
                "source": Observable {
                  "_isScalar": false,
                  "_subscribe": [Function],
                },
              },
            },
          },
        },
      },
    },
  },
  "log": Observable {
    "_isScalar": false,
    "operator": CatchOperator {
      "caught": [Circular],
      "selector": [Function],
    },
    "source": Observable {
      "_isScalar": false,
      "operator": FilterOperator {
        "predicate": [Function],
        "thisArg": undefined,
      },
      "source": Observable {
        "_isScalar": false,
        "source": Subject {
          "_isScalar": false,
          "closed": false,
          "hasError": false,
          "isStopped": false,
          "observers": Array [],
          "thrownError": null,
        },
      },
    },
  },
  "logEnable": [Function],
  "pid": Observable {
    "_isScalar": false,
    "operator": SwitchMapOperator {
      "project": [Function],
    },
    "source": Observable {
      "_isScalar": false,
      "operator": TimeoutWithOperator {
        "absoluteTimeout": false,
        "scheduler": AsyncScheduler {
          "SchedulerAction": [Function],
          "actions": Array [],
          "active": false,
          "now": [Function],
          "scheduled": undefined,
        },
        "waitFor": 1000,
        "withObservable": Observable {
          "_isScalar": false,
          "_subscribe": [Function],
        },
      },
      "source": Observable {
        "_isScalar": false,
        "operator": FilterOperator {
          "predicate": [Function],
          "thisArg": undefined,
        },
        "source": Observable {
          "_isScalar": false,
          "operator": CatchOperator {
            "caught": [Circular],
            "selector": [Function],
          },
          "source": Observable {
            "_isScalar": false,
            "operator": MapToOperator {
              "value": true,
            },
            "source": Observable {
              "_isScalar": false,
              "operator": MergeMapOperator {
                "concurrent": Infinity,
                "project": [Function],
              },
              "source": Observable {
                "_isScalar": false,
                "operator": FilterOperator {
                  "predicate": [Function],
                  "thisArg": undefined,
                },
                "source": Observable {
                  "_isScalar": false,
                  "_subscribe": [Function],
                },
              },
            },
          },
        },
      },
    },
  },
  "status": Observable {
    "_isScalar": false,
    "operator": SwitchMapOperator {
      "project": [Function],
    },
    "source": Observable {
      "_isScalar": false,
      "operator": TimeoutWithOperator {
        "absoluteTimeout": false,
        "scheduler": AsyncScheduler {
          "SchedulerAction": [Function],
          "actions": Array [],
          "active": false,
          "now": [Function],
          "scheduled": undefined,
        },
        "waitFor": 1000,
        "withObservable": Observable {
          "_isScalar": false,
          "_subscribe": [Function],
        },
      },
      "source": Observable {
        "_isScalar": false,
        "operator": FilterOperator {
          "predicate": [Function],
          "thisArg": undefined,
        },
        "source": Observable {
          "_isScalar": false,
          "operator": CatchOperator {
            "caught": [Circular],
            "selector": [Function],
          },
          "source": Observable {
            "_isScalar": false,
            "operator": MapToOperator {
              "value": true,
            },
            "source": Observable {
              "_isScalar": false,
              "operator": MergeMapOperator {
                "concurrent": Infinity,
                "project": [Function],
              },
              "source": Observable {
                "_isScalar": false,
                "operator": FilterOperator {
                  "predicate": [Function],
                  "thisArg": undefined,
                },
                "source": Observable {
                  "_isScalar": false,
                  "_subscribe": [Function],
                },
              },
            },
          },
        },
      },
    },
  },
  "version": Observable {
    "_isScalar": false,
    "operator": SwitchMapOperator {
      "project": [Function],
    },
    "source": Observable {
      "_isScalar": false,
      "operator": TimeoutWithOperator {
        "absoluteTimeout": false,
        "scheduler": AsyncScheduler {
          "SchedulerAction": [Function],
          "actions": Array [],
          "active": false,
          "now": [Function],
          "scheduled": undefined,
        },
        "waitFor": 1000,
        "withObservable": Observable {
          "_isScalar": false,
          "_subscribe": [Function],
        },
      },
      "source": Observable {
        "_isScalar": false,
        "operator": FilterOperator {
          "predicate": [Function],
          "thisArg": undefined,
        },
        "source": Observable {
          "_isScalar": false,
          "operator": CatchOperator {
            "caught": [Circular],
            "selector": [Function],
          },
          "source": Observable {
            "_isScalar": false,
            "operator": MapToOperator {
              "value": true,
            },
            "source": Observable {
              "_isScalar": false,
              "operator": MergeMapOperator {
                "concurrent": Infinity,
                "project": [Function],
              },
              "source": Observable {
                "_isScalar": false,
                "operator": FilterOperator {
                  "predicate": [Function],
                  "thisArg": undefined,
                },
                "source": Observable {
                  "_isScalar": false,
                  "_subscribe": [Function],
                },
              },
            },
          },
        },
      },
    },
  },
}
`;

exports[`openVpn should have connect and destroy properties 1`] = `
Object {
  "connect": Any<Function>,
  "disconnect": Any<Function>,
  "events": Any<AnonymousSubject>,
}
`;
